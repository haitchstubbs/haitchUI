<prompt>
    <task> 
        1. Improve the dialog component to match the quality of the popover component
        2. Create a test contract for the component using a11y 
        3. Create a collapsible.test file to run the contract 
    </task>
    <context>
        <instructions> 
            You are generating production-quality TypeScript and React code. 
            Core expectations: 
                - Use strict TypeScript (no any, no implicit any) 
                - Prefer modern React (function components, hooks) 
                - Follow React 18+ and Next.js App Router conventions when applicable 
                - Output must be copy-paste runnable (no pseudo-code) Style & structure: 
                - Prefer clear, explicit types over cleverness 
                - Keep components and functions small and composable 
                - Avoid unnecessary abstraction 
                - Use descriptive names 
                - Favor readability over brevity 
            React specifics: 
                - Prefer controlled components where appropriate 
                - Avoid unnecessary useEffect 
                - Memoize only when it clearly improves performance 
                - Follow accessibility best practices (ARIA, keyboard support) 
            State & data: 
                - Treat state as immutable 
                - Use explicit state transitions 
                - Handle loading, error, and empty states deliberately 
            Output rules: 
                - Include all required imports 
                - Do not omit implementation details 
                - Do not include explanations unless explicitly requested 
                - If multiple files are required, separate them with clear file headers 
        </instructions>
        <current-code>
            // packages/ui/src/components/dialog.tsx
            "use client";

            import * as React from "react";
            import * as ReactDOM from "react-dom";
            import { IconX } from "@tabler/icons-react"

            import { cn } from "../lib/cn";
            import { Slot } from "../lib/slot";

            type DialogContextValue = {
            open: boolean;
            modal: boolean;
            disabled: boolean;
            triggerRef: React.RefObject<HTMLElement | null>;
            contentRef: React.RefObject<HTMLDivElement | null>;
            restoreFocusRef: React.RefObject<HTMLElement | null>;
            titleId: string;
            descriptionId: string;
            contentId: string;
            setOpen: (next: boolean) => void;
            };

            const DialogContext = React.createContext<DialogContextValue | null>(null);

            function useDialogContext(componentName: string): DialogContextValue {
            const ctx = React.useContext(DialogContext);
            if (!ctx) throw new Error(`${componentName} must be used within <Dialog />`);
            return ctx;
            }

            function useControllableBoolean(params: {
            value: boolean | undefined;
            defaultValue: boolean | undefined;
            onChange: ((next: boolean) => void) | undefined;
            disabled: boolean;
            }): [boolean, (next: boolean) => void] {
            const { value, defaultValue, onChange, disabled } = params;
            const isControlled = value !== undefined;

            const [uncontrolled, setUncontrolled] = React.useState<boolean>(defaultValue ?? false);
            const current = isControlled ? value : uncontrolled;

            const set = React.useCallback(
                (next: boolean) => {
                if (disabled) return;
                if (!isControlled) setUncontrolled(next);
                onChange?.(next);
                },
                [disabled, isControlled, onChange]
            );

            return [current, set];
            }

            export type DialogProps = {
            open?: boolean;
            defaultOpen?: boolean;
            onOpenChange?: (open: boolean) => void;
            modal?: boolean;
            disabled?: boolean;
            children: React.ReactNode;
            };

            function Dialog({
            open,
            defaultOpen,
            onOpenChange,
            modal = true,
            disabled = false,
            children,
            }: DialogProps) {
            const triggerRef = React.useRef<HTMLElement | null>(null);
            const contentRef = React.useRef<HTMLDivElement | null>(null);
            const restoreFocusRef = React.useRef<HTMLElement | null>(null);

            const titleId = React.useId();
            const descriptionId = React.useId();
            const contentId = React.useId();

            const [isOpen, setOpen] = useControllableBoolean({
                value: open,
                defaultValue: defaultOpen,
                onChange: onOpenChange,
                disabled,
            });

            React.useEffect(() => {
                if (typeof document === "undefined") return;

                const handleFocusIn = (e: FocusEvent) => {
                if (!isOpen) {
                    const target = e.target as HTMLElement | null;
                    if (!target) return;
                    if (target === document.body) return;
                    if (target === document.documentElement) return;
                    restoreFocusRef.current = target;
                }
                };

                document.addEventListener("focusin", handleFocusIn);
                return () => document.removeEventListener("focusin", handleFocusIn);
            }, [isOpen]);

            const value = React.useMemo<DialogContextValue>(
                () => ({
                open: isOpen,
                modal,
                disabled,
                triggerRef,
                contentRef,
                restoreFocusRef,
                titleId,
                descriptionId,
                contentId,
                setOpen,
                }),
                [isOpen, modal, disabled, titleId, descriptionId, contentId, setOpen]
            );

            return (
                <DialogContext.Provider value={value}>
                <div data-slot="dialog">{children}</div>
                </DialogContext.Provider>
            );
            }

            export type DialogTriggerProps = Omit<
            React.ComponentPropsWithoutRef<"button">,
            "type" | "aria-haspopup" | "aria-expanded" | "aria-controls" | "disabled"
            > & {
            asChild?: boolean;
            };

            const DialogTrigger = React.forwardRef<HTMLButtonElement, DialogTriggerProps>(
            function DialogTrigger({ asChild, onClick, ...props }, forwardedRef) {
                const { open, setOpen, contentId, triggerRef, disabled } =
                useDialogContext("DialogTrigger");

                const Comp = asChild ? Slot : "button";

                const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
                onClick?.(e);
                if (e.defaultPrevented) return;
                setOpen(true);
                };

                return (
                <Comp
                    data-slot="dialog-trigger"
                    {...props}
                    ref={(node: HTMLButtonElement | null) => {
                    triggerRef.current = node;
                    if (typeof forwardedRef === "function") forwardedRef(node);
                    else if (forwardedRef) forwardedRef.current = node;
                    }}
                    type="button"
                    aria-haspopup="dialog"
                    aria-expanded={open}
                    aria-controls={contentId}
                    aria-disabled={disabled ? "true" : undefined}
                    onClick={disabled ? undefined : handleClick}
                />
                );
            }
            );

            export type DialogPortalProps = {
            container?: Element | null;
            children: React.ReactNode;
            };

            function DialogPortal({ container, children }: DialogPortalProps) {
            if (typeof document === "undefined") return null;
            const target = container ?? document.body;
            return ReactDOM.createPortal(<div data-slot="dialog-portal">{children}</div>, target);
            }

            export type DialogCloseProps = Omit<
            React.ComponentPropsWithoutRef<"button">,
            "type" | "disabled"
            > & {
            asChild?: boolean;
            };

            const DialogClose = React.forwardRef<HTMLButtonElement, DialogCloseProps>(
            function DialogClose({ asChild, onClick, ...props }, forwardedRef) {
                const { setOpen, disabled } = useDialogContext("DialogClose");

                const Comp = asChild ? Slot : "button";

                const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
                onClick?.(e);
                if (e.defaultPrevented) return;
                setOpen(false);
                };

                return (
                <Comp
                    data-slot="dialog-close"
                    {...props}
                    ref={forwardedRef}
                    type="button"
                    aria-disabled={disabled ? "true" : undefined}
                    onClick={disabled ? undefined : handleClick}
                />
                );
            }
            );

            export type DialogOverlayProps = React.ComponentPropsWithoutRef<"div"> & {
            closeOnInteractOutside?: boolean;
            };

            const DialogOverlay = React.forwardRef<HTMLDivElement, DialogOverlayProps>(
            function DialogOverlay(
                { className, closeOnInteractOutside = true, onMouseDown, ...props },
                forwardedRef
            ) {
                const { open, setOpen, modal, disabled } = useDialogContext("DialogOverlay");

                if (!open || !modal) return null;

                const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
                onMouseDown?.(e);
                if (e.defaultPrevented) return;
                if (disabled) return;
                if (closeOnInteractOutside && e.currentTarget === e.target) {
                    setOpen(false);
                }
                };

                return (
                <div
                    data-slot="dialog-overlay"
                    {...props}
                    ref={forwardedRef}
                    className={cn("fixed inset-0 z-50 bg-black/50", className)}
                    onMouseDown={handleMouseDown}
                />
                );
            }
            );

            function getFocusableWithin(root: HTMLElement): HTMLElement[] {
            const candidates = root.querySelectorAll<HTMLElement>(
                [
                'button:not([disabled])',
                '[href]',
                'input:not([disabled])',
                'select:not([disabled])',
                'textarea:not([disabled])',
                '[tabindex]:not([tabindex="-1"])',
                ].join(",")
            );
            return Array.from(candidates).filter((el) => {
                if (el.hasAttribute("disabled")) return false;
                if (el.getAttribute("aria-hidden") === "true") return false;
                return true;
            });
            }

            export type DialogContentProps = Omit<React.ComponentPropsWithoutRef<"div">, "role"> & {
            showCloseButton?: boolean;
            /**
            * Keep the dialog mounted when closed (uses hidden + aria-hidden).
            * For contracts/tests, set true.
            */
            forceMount?: boolean;
            container?: Element | null;
            };

            const DialogContent = React.forwardRef<HTMLDivElement, DialogContentProps>(
            function DialogContent(
                {
                className,
                children,
                showCloseButton = true,
                forceMount = false,
                container,
                onKeyDown,
                ...props
                },
                forwardedRef
            ) {
                const {
                open,
                setOpen,
                triggerRef,
                contentRef,
                restoreFocusRef,
                titleId,
                descriptionId,
                contentId,
                modal,
                disabled,
                } = useDialogContext("DialogContent");

                // Hooks MUST be called unconditionally (even when we "return null").
                React.useLayoutEffect(() => {
                if (open) {
                    const active = document.activeElement as HTMLElement | null;
                    if (
                    active &&
                    active !== document.body &&
                    active !== document.documentElement &&
                    !contentRef.current?.contains(active)
                    ) {
                    restoreFocusRef.current = active;
                    }

                    const node = contentRef.current;
                    if (!node) return;

                    const focusables = getFocusableWithin(node);
                    (focusables[0] ?? node).focus();
                } else {
                    queueMicrotask(() => {
                    (triggerRef.current ?? restoreFocusRef.current)?.focus();
                    });
                }
                }, [open, contentRef, triggerRef, restoreFocusRef]);

                const handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
                onKeyDown?.(e);
                if (e.defaultPrevented) return;

                if (disabled) return;

                if (e.key === "Escape") {
                    e.stopPropagation();
                    setOpen(false);
                    return;
                }

                if (modal && e.key === "Tab") {
                    const node = contentRef.current;
                    if (!node) return;

                    const focusables = getFocusableWithin(node);
                    if (focusables.length === 0) {
                    e.preventDefault();
                    node.focus();
                    return;
                    }

                    const first = focusables[0];
                    const last = focusables[focusables.length - 1];
                    if (!first || !last) return;

                    const active = document.activeElement as HTMLElement | null;

                    if (e.shiftKey) {
                    if (!active || active === first || !node.contains(active)) {
                        e.preventDefault();
                        last.focus();
                    }
                    } else {
                    if (!active || active === last || !node.contains(active)) {
                        e.preventDefault();
                        first.focus();
                    }
                    }
                }
                };

                const mounted = forceMount || open;
                if (!mounted) return null;

                return (
                <DialogPortal container={container}>
                    <DialogOverlay />
                    <div
                    data-slot="dialog-content"
                    {...props}
                    ref={(node: HTMLDivElement | null) => {
                        contentRef.current = node;
                        if (typeof forwardedRef === "function") forwardedRef(node);
                        else if (forwardedRef) forwardedRef.current = node;
                    }}
                    id={contentId}
                    role="dialog"
                    aria-modal={modal ? "true" : undefined}
                    aria-labelledby={titleId}
                    aria-describedby={descriptionId}
                    tabIndex={-1}
                    onKeyDown={handleKeyDown}
                    aria-hidden={open ? "false" : "true"}
                    hidden={!open}
                    className={cn(
                        "bg-background fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg outline-none sm:max-w-lg",
                        className
                    )}
                    >
                    {children}

                    {showCloseButton && (
                        <DialogClose
                        className="ring-offset-background focus:ring-ring absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
                        aria-label="Close"
                        >
                        <IconX />
                        <span className="sr-only">Close</span>
                        </DialogClose>
                    )}
                    </div>
                </DialogPortal>
                );
            }
            );

            export type DialogHeaderProps = React.ComponentPropsWithoutRef<"div">;
            function DialogHeader({ className, ...props }: DialogHeaderProps) {
            return (
                <div
                data-slot="dialog-header"
                className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
                {...props}
                />
            );
            }

            export type DialogFooterProps = React.ComponentPropsWithoutRef<"div">;
            function DialogFooter({ className, ...props }: DialogFooterProps) {
            return (
                <div
                data-slot="dialog-footer"
                className={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
                {...props}
                />
            );
            }

            export type DialogTitleProps = React.ComponentPropsWithoutRef<"h2"> & { asChild?: boolean };

            const DialogTitle = React.forwardRef<HTMLHeadingElement, DialogTitleProps>(
            function DialogTitle({ asChild, className, ...props }, forwardedRef) {
                const { titleId } = useDialogContext("DialogTitle");
                const Comp = asChild ? Slot : "h2";
                return (
                <Comp
                    data-slot="dialog-title"
                    {...props}
                    ref={forwardedRef}
                    id={titleId}
                    className={cn("text-lg leading-none font-semibold", className)}
                />
                );
            }
            );

            export type DialogDescriptionProps = React.ComponentPropsWithoutRef<"p"> & { asChild?: boolean };

            const DialogDescription = React.forwardRef<HTMLParagraphElement, DialogDescriptionProps>(
            function DialogDescription({ asChild, className, ...props }, forwardedRef) {
                const { descriptionId } = useDialogContext("DialogDescription");
                const Comp = asChild ? Slot : "p";
                return (
                <Comp
                    data-slot="dialog-description"
                    {...props}
                    ref={forwardedRef}
                    id={descriptionId}
                    className={cn("text-muted-foreground text-sm", className)}
                />
                );
            }
            );

            export {
            Dialog,
            DialogClose,
            DialogContent,
            DialogDescription,
            DialogFooter,
            DialogHeader,
            DialogOverlay,
            DialogPortal,
            DialogTitle,
            DialogTrigger,
            };

        </current-code>
        <examples>
            <popover-component>
            "use client";

            import * as React from "react";
            import {
                FloatingFocusManager,
                FloatingPortal,
                autoUpdate,
                flip,
                offset,
                shift,
                useClick,
                useDismiss,
                useFloating,
                useInteractions,
                useRole,
                useTransitionStyles,
                type Placement,
                type Strategy,
                type Middleware,
            } from "@floating-ui/react";

            import type { RectLike, VirtualElement } from "@haitch/core";
            import { useOverlayDOMManager, type OverlayDOM } from "@haitch/core/client";
            import { Slot } from "../lib/slot";
            import { composeRefs } from "../lib/compose-refs";
            import { cn } from "../lib/cn";

            type Side = "top" | "right" | "bottom" | "left";
            type Align = "start" | "center" | "end";

            function placementFromSideAlign(side: Side, align: Align): Placement {
                if (align === "center") return side;
                return `${side}-${align}` as Placement;
            }

            function sideFromPlacement(p: Placement): Side {
                return p.split("-")[0] as Side;
            }

            function alignFromPlacement(p: Placement): Align {
                const parts = p.split("-");
                return (parts[1] as Align) ?? "center";
            }

            type PopoverContextValue = {
                open: boolean;
                setOpen: (open: boolean) => void;

                // positioning
                placement: Placement;
                refs: ReturnType<typeof useFloating>["refs"];
                floatingStyles: React.CSSProperties;
                getReferenceProps: ReturnType<typeof useInteractions>["getReferenceProps"];
                getFloatingProps: ReturnType<typeof useInteractions>["getFloatingProps"];

                portalRoot: HTMLElement | null;

                modal: boolean;
                closeOnOutsidePress: boolean;
                closeOnEscape: boolean;

                // shadow-dom-safe outside press
                isOutside: (event: Event) => boolean;

                // transition (Radix-like presence)
                isMounted: boolean;
                transitionStyles: React.CSSProperties;

                // per-content overrides
                setContentOverrides: (overrides: {
                    side?: Side;
                    align?: Align;
                    sideOffset?: number;
                }) => void;
            };

            const PopoverContext = React.createContext<PopoverContextValue | null>(null);

            function usePopoverContext() {
                const ctx = React.useContext(PopoverContext);
                if (!ctx) throw new Error("Popover components must be used within <Popover>.");
                return ctx;
            }

            type PopoverProps = {
                dom?: OverlayDOM;

                open?: boolean;
                defaultOpen?: boolean;
                onOpenChange?: (open: boolean) => void;

                // shadcn-like API
                side?: Side;
                align?: Align;
                sideOffset?: number;

                strategy?: Strategy;
                middleware?: Middleware[];

                closeOnEscape?: boolean;
                closeOnOutsidePress?: boolean;
                modal?: boolean;

                // Virtual reference support (canvas/webgl)
                virtualRect?: RectLike;
                virtualContextElement?: Element | null;
            };

            function useControllableOpen(opts: Pick<PopoverProps, "open" | "defaultOpen" | "onOpenChange">) {
                const [uncontrolled, setUncontrolled] = React.useState<boolean>(opts.defaultOpen ?? false);
                const controlled = typeof opts.open === "boolean";
                const open = controlled ? (opts.open as boolean) : uncontrolled;

                const setOpen = React.useCallback(
                    (next: boolean) => {
                        if (!controlled) setUncontrolled(next);
                        opts.onOpenChange?.(next);
                    },
                    [controlled, opts]
                );

                return { open, setOpen };
            }

            export function Popover(props: React.PropsWithChildren<PopoverProps>) {
                const parentManager = useOverlayDOMManager();
                const manager = React.useMemo(() => parentManager.fork(props.dom), [parentManager, props.dom]);
                const dom = manager.dom;

                const { open, setOpen } = useControllableOpen(props);

                const [contentOverrides, setContentOverrides] = React.useState<{
                    side?: Side;
                    align?: Align;
                    sideOffset?: number;
                }>({});

                const placement = React.useMemo<Placement>(() => {
                    const side = contentOverrides.side ?? props.side ?? "bottom";
                    const align = contentOverrides.align ?? props.align ?? "center";
                    return placementFromSideAlign(side, align);
                }, [contentOverrides.side, contentOverrides.align, props.side, props.align]);

                const middleware = React.useMemo(() => {
                    const m: Middleware[] = [];
                    const resolvedOffset = contentOverrides.sideOffset ?? props.sideOffset ?? 4;
                    m.push(offset(resolvedOffset)); // shadcn default-ish
                    m.push(flip());
                    m.push(shift({ padding: 8 }));
                    if (props.middleware?.length) m.push(...props.middleware);
                    return m;
                }, [contentOverrides.sideOffset, props.sideOffset, props.middleware]);

                const floating = useFloating({
                    open,
                    onOpenChange: setOpen,
                    placement,
                    strategy: props.strategy ?? "absolute",
                    middleware,
                    whileElementsMounted: autoUpdate,
                });

                // Virtual reference support (canvas/webgl)
                React.useEffect(() => {
                    if (!props.virtualRect) return;
                    const ve: VirtualElement = dom.createVirtualElement(props.virtualRect, {
                        contextElement: props.virtualContextElement,
                    });
                    floating.refs.setReference(ve as any);
                    // eslint-disable-next-line react-hooks/exhaustive-deps
                }, [props.virtualRect, props.virtualContextElement, dom]);

                const closeOnEscape = props.closeOnEscape ?? true;
                const closeOnOutsidePress = props.closeOnOutsidePress ?? true;
                const modal = props.modal ?? false;

                const isOutside = React.useCallback(
                    (event: Event) => dom.isEventOutside(event, [floating.refs.reference.current as any, floating.refs.floating.current as any]),
                    [dom, floating.refs]
                );

                const click = useClick(floating.context, { enabled: true });
                const dismiss = useDismiss(floating.context, {
                    enabled: true,
                    escapeKey: closeOnEscape,
                    outsidePressEvent: "pointerdown",
                    outsidePress: (event) => {
                        if (!closeOnOutsidePress) return false;

                        const refEl = floating.refs.reference.current as HTMLElement | null;
                        const floatEl = floating.refs.floating.current as HTMLElement | null;

                        const target = event.target as Node | null;

                        // Plain containment guard first (works for normal DOM)
                        if (target && refEl?.contains(target)) return false;
                        if (target && floatEl?.contains(target)) return false;

                        // Shadow/portal safe fallback
                        return dom.isEventOutside(event, [refEl as any, floatEl as any]);
                    },
                });

                const role = useRole(floating.context, { role: "dialog" });

                const { getReferenceProps, getFloatingProps } = useInteractions([click, dismiss, role]);

                const [portalRoot, setPortalRoot] = React.useState<HTMLElement | null>(null);

                React.useEffect(() => {
                    if (typeof document === "undefined") return;
                    setPortalRoot(dom.getPortalContainer());
                }, [dom]);

                // Radix-like presence so "closed" can animate out.
                // (You can also rely purely on Tailwind data-[state=...] classes; this ensures it stays mounted briefly.)
                const { isMounted, styles: transitionStyles } = useTransitionStyles(floating.context, {
                    duration: { open: 120, close: 100 },
                    initial: { opacity: 0, transform: "scale(0.95)" },
                    open: { opacity: 1, transform: "scale(1)" },
                    close: { opacity: 0, transform: "scale(0.95)" },
                });

                const value = React.useMemo<PopoverContextValue>(
                    () => ({
                        open,
                        setOpen,
                        placement,
                        refs: floating.refs,
                        floatingStyles: floating.floatingStyles,
                        getReferenceProps,
                        getFloatingProps,
                        portalRoot,
                        modal,
                        closeOnOutsidePress,
                        closeOnEscape,
                        isOutside,
                        isMounted,
                        transitionStyles,
                        setContentOverrides,
                    }),
                    [
                        open,
                        setOpen,
                        placement,
                        floating.refs,
                        floating.floatingStyles,
                        getReferenceProps,
                        getFloatingProps,
                        portalRoot,
                        modal,
                        closeOnOutsidePress,
                        closeOnEscape,
                        isOutside,
                        isMounted,
                        transitionStyles,
                        setContentOverrides,
                    ]
                );

                return <PopoverContext.Provider value={value}>{props.children}</PopoverContext.Provider>;
            }

            type PopoverTriggerProps = React.HTMLAttributes<HTMLElement> & {
                asChild?: boolean;
            };

            export const PopoverTrigger = React.forwardRef<HTMLElement, PopoverTriggerProps>(function PopoverTrigger(
                { asChild, children, ...props },
                forwardedRef
            ) {
                const ctx = usePopoverContext();
                const mergedRef = composeRefs(forwardedRef, ctx.refs.setReference as any);

                const triggerProps = ctx.getReferenceProps({
                    ...(props as any),
                    ref: mergedRef,
                    "data-slot": "popover-trigger",
                    "data-state": ctx.open ? "open" : "closed",
                });

            React.useEffect(() => {
            console.log("reference node:", ctx.refs.reference.current);
            }, [ctx.refs.reference]);

                if (asChild) return <Slot {...(triggerProps as any)}>{children}</Slot>;
                return <span {...(triggerProps as any)}>{children}</span>;
            });

            type PopoverAnchorProps = React.HTMLAttributes<HTMLElement> & {
                asChild?: boolean;
            };

            /**
            * Optional, shadcn-compatible helper:
            * <PopoverAnchor /> lets you set the positioning anchor without being the click trigger.
            */
            export const PopoverAnchor = React.forwardRef<HTMLElement, PopoverAnchorProps>(function PopoverAnchor({ asChild, children, ...props }, forwardedRef) {
                const ctx = usePopoverContext();
                const mergedRef = composeRefs(forwardedRef, ctx.refs.setReference as any);

                const anchorProps = {
                    ...props,
                    ref: mergedRef,
                    "data-slot": "popover-anchor",
                };

                if (asChild) return <Slot {...(anchorProps as any)}>{children}</Slot>;
                return <span {...(anchorProps as any)}>{children}</span>;
            });

            type PopoverContentProps = React.HTMLAttributes<HTMLDivElement> & {
                asChild?: boolean;
                className?: string;

                // shadcn-ish props
                side?: Side;
                align?: Align;
                sideOffset?: number;
            };

            export const PopoverContent = React.forwardRef<HTMLDivElement, PopoverContentProps>(function PopoverContent(
                { asChild, children, style, className, side, align, sideOffset, ...props },
                forwardedRef
            ) {
                const ctx = usePopoverContext();

                React.useEffect(() => {
                    ctx.setContentOverrides({ side, align, sideOffset });
                    return () => ctx.setContentOverrides({});
                }, [ctx, side, align, sideOffset]);

                if (!ctx.isMounted) return null;

                const placementSide = sideFromPlacement(ctx.placement);
                const resolvedAlign = align ?? alignFromPlacement(ctx.placement);

                const floatingProps = ctx.getFloatingProps({
                    ...props,
                    ref: composeRefs(forwardedRef, ctx.refs.setFloating as any),
                    "data-slot": "popover-content",
                    "data-state": ctx.open ? "open" : "closed",
                    "data-side": placementSide,
                    "data-align": resolvedAlign,
                    style: {
                        ...ctx.floatingStyles,
                        ...ctx.transitionStyles,
                        ...style,
                        transform: [
                            ctx.floatingStyles.transform,
                            ctx.transitionStyles.transform,
                            style?.transform,
                        ]
                            .filter(Boolean)
                            .join(" "),
                    },
                    className: cn(
                        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-ui-radius border border-border p-4 shadow-md outline-hidden",
                        className
                    ),
                } as React.HTMLAttributes<HTMLDivElement>);

                const node = asChild ? <Slot {...(floatingProps as any)}>{children}</Slot> : <div {...floatingProps}>{children}</div>;

                const maybeFocusManaged = ctx.modal ? (
                    <FloatingFocusManager context={ctx.refs.floating as any} modal={true}>
                        {node}
                    </FloatingFocusManager>
                ) : (
                    node
                );

                return <FloatingPortal root={ctx.portalRoot}>{maybeFocusManaged}</FloatingPortal>;
            });

            </popover-component>
        </examples>
        <imported-functions-and-libs>
                <haitch-ui-core>
                export type VirtualElement = {
                    getBoundingClientRect: () => DOMRect;
                    contextElement?: Element | null;
                };

                export type RectLike = {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                };
            </haitch-ui-core>
            <haitch-ui-core-client>
                "use client";


                import { createContext, useContext, useMemo } from "react";
                import { UI } from "./manager";
                import type { OverlayDOM, OverlayDOMContextValue, ResolvedOverlayDOM } from "./types";
                import type { ReactNode } from "react";

                const DEFAULT_MANAGER = UI.default();
                const DEFAULT_VALUE: OverlayDOMContextValue = {
                manager: DEFAULT_MANAGER,
                dom: DEFAULT_MANAGER.dom,
                };

                const OverlayDOMContext = createContext<OverlayDOMContextValue>(DEFAULT_VALUE);

                export function OverlayDOMProvider(props: { dom?: OverlayDOM; children: ReactNode }) {
                const parent = useContext(OverlayDOMContext);

                const manager = useMemo(() => {
                    // child overrides parent; parent chain is represented by parent.manager
                    return parent.manager.fork(props.dom);
                }, [parent.manager, props.dom]);

                const value = useMemo<OverlayDOMContextValue>(() => ({ manager, dom: manager.dom }), [manager]);

                return <OverlayDOMContext.Provider value={value}>{props.children}</OverlayDOMContext.Provider>;
                }

                export function useOverlayDOM(): ResolvedOverlayDOM {
                return useContext(OverlayDOMContext).dom;
                }

                /**
                * Optional: expose the manager if you want to use helper methods
                * without passing dom around.
                */
                export function useOverlayDOMManager(): UI {
                return useContext(OverlayDOMContext).manager;
                }

            </haitch-ui-core-client>
            <slot>
                import * as React from "react";
                import { composeRefs } from "./compose-refs";

                type AnyProps = Record<string, unknown>;

                export const Slot = React.forwardRef<HTMLElement, { children: React.ReactNode } & AnyProps>(
                function Slot(props, forwardedRef) {
                    const { children, ...slotProps } = props;

                    if (!React.isValidElement(children)) {
                    throw new Error("Slot expects a single valid React element child.");
                    }

                    const child = children as React.ReactElement<any>;

                    // IMPORTANT: ref is on the element, not in props
                    const childRef = (child.props as any).ref ?? (child as any).ref;

                    const childProps = child.props ?? {};
                    const mergedProps: any = { ...childProps, ...slotProps };

                    // merge className
                    if (childProps.className && (slotProps as any).className) {
                    mergedProps.className = `${childProps.className} ${(slotProps as any).className}`;
                    }

                    // merge style (optional but good)
                    if (childProps.style && (slotProps as any).style) {
                    mergedProps.style = { ...childProps.style, ...(slotProps as any).style };
                    }

                    // compose common event handlers (if both exist)
                    const events = [
                    "onClick",
                    "onPointerDown",
                    "onPointerUp",
                    "onMouseEnter",
                    "onMouseLeave",
                    "onFocus",
                    "onBlur",
                    ] as const;

                    for (const key of events) {
                    const a = childProps[key];
                    const b = (slotProps as any)[key];
                    if (typeof a === "function" && typeof b === "function") {
                        mergedProps[key] = (...args: any[]) => {
                        a(...args);
                        b(...args);
                        };
                    }
                    }

                    // compose refs (use child.ref, not child.props.ref)
                    mergedProps.ref = composeRefs(childRef, forwardedRef as any);

                    return React.cloneElement(child, mergedProps);
                }
                );

            </slot>
            <compose-refs>
                import * as React from "react";

                export function composeRefs<T>(...refs: Array<React.Ref<T> | undefined>) {
                return (node: T | null) => {
                    for (const ref of refs) {
                    if (!ref) continue;
                    if (typeof ref === "function") ref(node);
                    else (ref as React.MutableRefObject<T | null>).current = node;
                    }
                };
                }
            </compose-refs>
        </imported-functions-and-libs>
    </context>
</prompt>